{\rtf1\ansi\ansicpg1251\uc1 \deff0\deflang1033\deflangfe1049{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f54\froman\fcharset238\fprq2 Times New Roman CE;}{\f55\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f57\froman\fcharset161\fprq2 Times New Roman Greek;}{\f58\froman\fcharset162\fprq2 Times New Roman Tur;}{\f59\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f66\fmodern\fcharset238\fprq1 Courier New CE;}{\f67\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f69\fmodern\fcharset161\fprq1 Courier New Greek;}{\f70\fmodern\fcharset162\fprq1 Courier New Tur;}{\f71\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\lang1049\cgrid \snext0 Обычный;}{\*\cs10 \additive Основной шрифт;}}{\*\listtable{\list\listtemplateid-1825560680\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat16\levelold\levelspace0\levelindent283{\leveltext\'052.\'00. ;}{\levelnumbers\'03;}\b\i0\f0\fs24\ulnone\fbias0 \fi-283\li283 }{\listname ;}\listid143932531}}{\*\listoverridetable{\listoverride\listid143932531\listoverridecount0\ls1}}{\info{\title Билет16 Часть2}{\subject GOS}{\author Dmitry D. Kozlov}{\operator Дмитрий Викторович Царьков}{\creatim\yr1998\mo5\dy28\hr12\min44}{\revtim\yr1998\mo6\dy5\hr21\min38}{\version3}{\edmins14}{\nofpages2}{\nofwords820}{\nofchars4677}{\*\company REDLAB}{\nofcharsws5743}{\vern73}}\paperw11906\paperh16838 \widowctrl\ftnbj\aenddoc\lytprtmet\formshade\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\pntext\pard\plain\b\cgrid \hich\af0\dbch\af0\loch\f0 2.16. \tab}\pard\plain \fi-283\li283\nowidctlpar\widctlpar{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec\pnb1\pni0\pnfs24\pnstart16\pnindent283\pnhang{\pntxtb 2.}{\pntxta . }}\ls1\adjustright \fs20\lang1049\cgrid {\b\f55\fs24 Алгоритм Сети-Ульмана оптимального распределения регистров.
\par }\pard \nowidctlpar\widctlpar\adjustright { 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Пусть  система  команд  машины  имеет  неограниченное  число универсальных регистров,  в которых выполняются арифметические команды. Рассмотрим,  как можно  сгенерировать код,  используя для  данного   арифметического  выражения   минимальное  число регистров.
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                             |
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                            / \\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                        R1 /\\  \\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                           --  /\\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                           R2 /\\ \\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                              -- /\\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                             Rn /\\ \\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                                --  \\
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                                    /\\LR
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                                  L/\\/\\R
\par }\pard \sl20\slmult0\nowidctlpar\widctlpar\adjustright {\f2                                   ----
\par }\pard \nowidctlpar\widctlpar\adjustright {\f67                             Рис. 8.13}{
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Предположим    сначала,     что    распределение     регистров осуществляется  по   простейшей   схеме   слева-направо,   как изображено на  рис. 8.13.  Тогда к  моменту генерации кода для поддерева LR  занято n регистров. Пусть поддерево L требует nl регистров, а  поддерево R  - nr  регистров. Если nl=nr, то при вычислении L  будет использовано  nl регистров и под результат будет занят  n+1-й  регистр.  Еще  nr  (=nl)  регистров  будет использовано при  вычислении R.  Таким  образом,  общее  число использованных регистров будет равно n+nl+1. Если nl>nr,  то  при  вычислении  L  будет  использовано  nl регистров.  При   вычислении  R   будет   использовано   nr<nl регистров, и  всего  будет  использовано  не  более  чем  n+nl регистров.
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Если nl<nr,  то после вычисления L под результат будет занят один  регистр   (предположим  n+1-й)   и  nr  регистров  будет использовано для вычисления R. Всего будет использовано n+nr+1 регистров. Видно, что  для деревьев, совпадающих с точностью до порядка потомков  каждой  вершины,  минимальное  число  регистров  при распределении  их   слева-направо  достигается  на  дереве,  у которого в  каждой вершине  слева расположено  более "сложное" поддерево, требующее большего числа регистров.   Таким образом,  если дерево  таково, что в каждой внутренней вершине правое поддерево требует меньшего числа регистров, чем левое, то,  обходя  дерево  слева  направо,  можно  оптимально распределить регистры.   Без перестройки  дерева это  означает, что  если в некоторой вершине дерева  справа расположено более сложное поддерево, то сначала сгенерируем  код для  него, а  затем  уже  для  левого поддерева.   Алгоритм работает  следующим образом. Сначала осуществляется разметка синтаксического  дерева по следующим правилам.
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Правила разметки:
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   1)  если  вершина  -  правый  лист  или  дерево  состоит  из единственной вершины,  помечаем эту  вершину  числом  1,  если вершина - левый лист, помечаем ее 0 (рис. 8.14).
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2         |          |             R                R
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2        / \\        / \\            |                |
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2       /   \\      /   \\        ll/ \\lr          ll/ \\lr
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2      0    /\\    /\\    1        /   \\            /   \\
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2          /  \\  /  \\          R+1    R          R     R+1
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2          ----  ----
\par }\pard \nowidctlpar\widctlpar\adjustright {\f67           а)     б)           а) ll<lr          б) ll>=lr
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f67          Рис. 8.14                 Рис. 8.15
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   2) если  вершина имеет прямых потомков с метками l1 и l2, то в качестве метки этой вершины выбираем большее из чисел l1 или l2 либо число l1+1, если l1=l2. Эта разметка  позволяет  определить,  какое  из  поддеревьев требует большего количества регистров для своего вычисления. Затем осуществляется распределение регистров для результатов операций.
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Правила распределения регистров:
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   1) Корню назначается первый регистр.
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   2) Если метка левого потомка меньше метки правого, то левому потомку назначается  регистр на единицу больший, чем предку, а правому  -  с  тем  же  номером  (сначала  вычисляется  правое поддерево и  его результат  помещается в  регистр R).  Если же метка левого  потомка больше  или равна метке правого потомка, то  наоборот,   сначала  вычисляется  левое   поддерево  и  его результат помещается  в регистр  R (рис.  8.15).  После  этого формируется код по следующим правилам.
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   Правила генерации кода:
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   1)  если   вершина  -   правый  лист   с  меткой  1,  то  ей соответствует код  LOAD X,R, где R - регистр, назначенный этой вершине, а  X -  адрес переменной,  связанной с вершиной (рис. 8.16.б);
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   2) если  вершина внутренняя  и ее  левый потомок  -  лист  с меткой 0, то ей соответствует код
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55  Код правого поддерева
\par }\pard \nowidctlpar\widctlpar\adjustright { Op X,R
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 где снова  R -  регистр, назначенный  этой вершине,  X - адрес переменной, связанной с вершиной, а Op - операция, примененная в вершине (рис. 8.16.а);
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   3) если  непосредственные потомки  вершины не листья и метка правой вершины  больше метки  левой, то  вершине соответствует код
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   Код правого поддерева
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   Код левого поддерева
\par }\pard \nowidctlpar\widctlpar\adjustright {  Op R+1,R
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 где R  - регистр,  назначенный внутренней  вершине, и операция Op, вообще говоря, не коммутативная (рис. 8.17 б)).
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2     R                R             R                R
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2     |                |             |                |
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2    / \\              / \\           / \\              / \\
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2   /   \\R         R /   \\        R/   \\R+1      R+1/   \\R
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2  X    /\\          /\\    X       /\\   /\\          /\\   /\\
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2 (0)   --          --   (1)      --   --          --   --
\par }\pard \nowidctlpar\widctlpar\adjustright {\f67     а)               б)            а)               б)
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f67           Рис. 8.16                   Рис. 8.17
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Если  метка  правой  вершины  меньше  или  равна  метке  левой вершины, то вершине соответствует код
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   Код левого поддерева
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55   Код правого поддерева
\par }\pard \nowidctlpar\widctlpar\adjustright {  Op R,R+1
\par }\pard \nowidctlpar\widctlpar\adjustright {  MOVE R+1,R
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }\pard \nowidctlpar\widctlpar\adjustright {\f55 Последняя  команда   генерируется  для  того,  чтобы  получить результат в  нужном регистре  (в случае коммутативной операции операнды  операции   можно   поменять   местами   и   избежать}{ }{\f55 дополнительной пересылки)(рис. 8.17 а)).
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }}